use graphblas_sparse_linear_algebra::collections::sparse_vector::SparseVector;
use graphblas_sparse_linear_algebra::index::ElementIndexSelector;
use graphblas_sparse_linear_algebra::operators::binary_operator::{
    Assignment,
};
use graphblas_sparse_linear_algebra::operators::insert::{
    InsertVectorIntoColumn, InsertVectorIntoColumnTrait,
};
use graphblas_sparse_linear_algebra::operators::insert::{
    InsertVectorIntoRow, InsertVectorIntoRowTrait,
};
use graphblas_sparse_linear_algebra::operators::options::OperatorOptions;
use once_cell::sync::Lazy;

use crate::error::GraphComputingError;
use crate::graph::edge_store::weighted_adjacency_matrix::{
    GetGraphblasContext, WeightedAdjacencyMatrix,
};
use crate::graph::graph::VertexIndex;

use super::GetMatrixSize;

static DEFAULT_GRAPHBLAS_OPERATOR_OPTIONS: Lazy<OperatorOptions> =
    Lazy::new(|| OperatorOptions::new_default());

static INSERT_VECTOR_INTO_COLUMN_OPERATOR: Lazy<InsertVectorIntoColumn> =
    Lazy::new(|| InsertVectorIntoColumn::new());

static INSERT_VECTOR_INTO_ROW_OPERATOR: Lazy<InsertVectorIntoRow> =
    Lazy::new(|| InsertVectorIntoRow::new());

// TODO: this doesn't work because Lazy generates a one-off type that doesn't implement AccumulatorBinaryOperator.
// static BOOLEAN_ASSIGNMENT_OPERATOR: Lazy<Assignment<bool>> = Lazy::new(|| Assignment::<bool>::new());

static OPERATOR_CACHE: Lazy<OperatorCache> = Lazy::new(|| OperatorCache::new());

pub(crate) trait DeleteVertexConnections {
    fn delete_vertex_connections_unchecked(
        &mut self,
        vertex_index: &VertexIndex,
    ) -> Result<(), GraphComputingError>;
}

impl DeleteVertexConnections for WeightedAdjacencyMatrix {
    fn delete_vertex_connections_unchecked(
        &mut self,
        vertex_index: &VertexIndex,
    ) -> Result<(), GraphComputingError> {
        // TODO: does the value type mismatch actually cause a performance penalty? Since the vector is empty, it may not.
        // TODO: is there a benefit to caching an empty vector (and matrix) in the edge/vertex store? The cached vector/matrix
        // could be selected by the ValueTypeIdentifier.
        // TODO: a vector/matrix of the correct size and value type could be generated by the ValueTypeIdentifier,
        // this would cost a match statement.
        let empty_column =
            SparseVector::<bool>::new(&self.graphblas_context_ref(), &self.vertex_capacity()?)?;

        // TODO: is inserting an empty vector the fastest way to delete a row/column?
        INSERT_VECTOR_INTO_COLUMN_OPERATOR.apply(
            self,
            &ElementIndexSelector::All,
            vertex_index,
            &empty_column,
            &OPERATOR_CACHE.boolean_assignment,
            &DEFAULT_GRAPHBLAS_OPERATOR_OPTIONS,
        )?;
        INSERT_VECTOR_INTO_ROW_OPERATOR.apply(
            self,
            &ElementIndexSelector::All,
            vertex_index,
            &empty_column,
            &OPERATOR_CACHE.boolean_assignment,
            &DEFAULT_GRAPHBLAS_OPERATOR_OPTIONS,
        )?;
        Ok(())
    }
}

struct OperatorCache {
    boolean_assignment: Assignment<bool>,
}

impl OperatorCache {
    fn new() -> OperatorCache {
        OperatorCache {
            boolean_assignment: Assignment::<bool>::new(),
        }
    }
}
